================================
Parallel Replica
================================
Parallel Replica Dynamics (PRD) is the simplest and the most accurate way to do accelerated-MD simulation. The only assumption made in this method is that the reactions satisfy frst order kinetics: PRD boosts the simulation linearly with the number of replicas and can be easily combined with with other methods for extending the MD time scale, e.g. Hyperdynamics method, giving a multiplicative effect in the time scale gain.
  .. math::

     Pr(t) = k\ exp(- k\ t)

In Voter's approach,  N replicas of the system are made at first and then the momentum in each replica is randomized and dephasing stage is employed to decorrlecate their motions. The simulation clock starts after this dephasing stage and stops when the first transitions is detected in any of replica. Because those N trajectories are independent, thery can explore the phase space N times faster than using a single trajectory. The overall simulation clock is advanced by the sum of all the simulation times in relicas. 

In order to work with distributed architectures, we used a little different way to run PRD. The replica generating and dephasing stage is exactly the same. We make all replicas run the same length of MD steps (:math:`max\_time=max\_step*time\_step`). Results will only be reported back until the client finished those steps. The server accumluate the the simulation clock by :math:`dt` until the first transition is reported back.
  .. math::

         dt=\begin{equation}
           \left\{
              \begin{aligned}
                   max\_time & \        {\rm Failed\ to\ transit}  \\
                   transition\_time &\  {\rm Successful\ transited} \\
                           \end{aligned}
                              \right.
                                \end{equation}

In order to run Parallel Replica, please set **job** to *parallel_replica* in **[Main]**. For regular MD all the parameters could be set in the **[Dynamics]** section. Our Parallel Replica could also be combined with Hyperdynamics using Bond-Boost method. You can use this feature by setting **bias_potential** = *bond_boost* in **[Hyperdynamics]** section.

For detailed information about Parallel Replica and Bond-Boost, please refer to the following paper:

::

   "Parallel replica method for dynamics of infrequent events‚Äù
                                        A. F. Voter, Phys Rev B 57 13985 (1998)

   "Accelerated molecular-dynamics of rare events with the bond-boost method"
               R. A. Miron and K. A. Fichthorn, J. Chem. Phys. 119, 6210 (2003)

Main
-------------------------------
In order to run Parallel Replica, please set **job** to *parallel_replica* in **[Main]**.

**temperature** [300]
  Temperature during the Molecular Dynamics run. At the beginning, the code will scale the velocities to that temperature. And the thermostat you choose will maintain the temperature during the MD run. And the simulation termperature in this code is calculated as:

  .. math::

     T_k = \frac{2\ E_{kin}}{k_B\ N_{freedom}}




Dynamics
--------------------------------

**time_step** [1]
  The length of each MD step. The unit of **timestep** is *1 fs* and default value is *1*.
    
**auto_stop** [False]
  Whether or not stop the job when a new state is found. For boinc communicator this value should be set to *false*. 
    
**steps** [1000]
   The maxium number of MD steps. The job will only be stopped when the steps of MD run reaches **max_steps**, if **auto_stop** is set to be *false*.
    
**dephase_steps** [200]
  Number of steps used to decorrelate the replica trajectories. The momenta will be inversed when reaching the divding surface to prevent the occurring of transitions during this period. 

**check_period** [500]
  How frequent you check the state of system. Every **check_period** steps, the current structure and the initial one will be compared  to tell whether a newstate has been reached. Also note when you set **refine** as *true*, the code will keep an buff array consisted by **int(check_period/record_resolution)+1** Matter objects, which may increase the usage of memory.

**refine** [True] 
  Whether or not the exact transition step is refined. When this option is turned on, the code will keep an array consisted by **int(check_period/record_resolution)+1** Matter objects. And Binary search algorithm is employed to determine the exact transition step. Otherwise the transition step would be the first newstate we found. This function could help to reduce state-check frequecy without lowering the accuracy. And the accuracy of transition time is **record_resolution*timestep**.

::
    
        refine = T
        record_resolution = 1

**record_resolution** [1]
  How often the system is recorded to the buff array when **refine** option is activated. By raising the value of **record_resolution** you may lower the accuarcy of transition time but largely reduce the usage of memory and speed up the refinement of transition step.
  
**relax_steps** [500]
   Number of additional MD run which will be  performed after a new state has been found. A state check will also be employed after these **relax_steps** to confirm the state found before is a real new state. This additional check could help to avoid recrossing and mega-stable state. It is recommended to set this value approximately around **dephase_steps**.

**thermo_type** 
  Default: *andersen*

  Options:

         *andersen* : Andersen thermostat with Verlet algorithm

         *nose-hoover* : Nose-Hover thermostat with Verlet algorithm(not available now)

  Thermostat method you choose to perform NVT ensemble molecular dynamics. Currently only Andersen thermostat is available and well tested. Nose-Hoover thermostat is implmented but doesn't work correctly. 

**andersen_alpha** [0.2]
  The collision strength :math:`\alpha` in Andersen thermostat. If a collision happened, the new velocity is: 

.. math::

  V_{new} = \sqrt{(1-\alpha^2)}*V_{old}+\alpha*V_{guassian}

**andersen_tcol** [10]
  The collision frequency in Andersen thermostat. 
    
**nose_mass** [0]
  The effective mass of the additional degree of freedom in Nose-Hoover thermostat, which determines rate of the heat transfer.
    
Hyperdynamics
--------------------------------

**bias_potentialt** 
   Default: *none*

   Options:
            *none* : with no bias potential, run regular MD 

            *bond_boost* : bond boost method from K. A. Fichthorn
   
   Options for different types of bias potential in Hyperdynamics. 
  
**bb_dvmax** [0.0]
  Bond-Boost paramerter. The magnitude of the total boost potential. It should be smaller than the barrier of any transition.
 
**bb_rmd_steps** [200]
  Bond-Boost paramerter. Number of regular MD run to get the equilibrium bond length before boost potential is added.
  
**bb_stretch_threshold** [0.001]
  Bond-Boost paramerter, defines the dividing surface. It should be smaller than the maximum fractional nearest-neighbor bond stretch or compression  at any transtion state. 
  
**bb_ds_curvature** [0.9]
  Bond-Boost paramerter. The curvature near the dividing suface, it should has a value <= 1. We recommend the value to be *0.9-0.98*.

**bb_rcut** [3.0]
  Bond-Boost paramerter. All bonds which belong to the tagged atoms and are shorter than a cutoff of rcut will be boostd.








