* Conventions
- Always use ~clang-format~.
- All strings must be explicitly identified ~""s~
  + **not for doc-strings** in ~pybind11~
** General
- Always use ~namespace py = pybind11;~
- For ~Blah.cpp~ the binding will be ~pybinds/py_blah.cc~
- Most header content must be in ~pybinds/py_wrapper.hpp~
  + The exceptions are base classes like ~py_potential.hpp~ since these need to be imported by child files like ~potentials/py_morse.cc~
- Every method must have:
  + arguments defined
  + documentation string
Example:
#+begin_src c++
.def("setCell", &Matter::setCell, "Sets the cell dimensions"s, py::arg("AtomMatrix newCell"))
#+end_src
** Class boilerplate

#+begin_src c++
void py_objectName(py::module_ &m) {
    py::class_<ObjectName>(m, "ObjectName", py::dynamic_attr()) // dynamic incurs a penalty
    /*
    ,** Constructors
    ,*/

    /*
    ,** Operators
    ,*/

    /*
    ,** Methods
    ,*/

    /*
    ,** Parameters
    ,*/

    /*
    ,** Python helpers
    ,*/

    .def("__repr__", [](const ObjectName &a) { return "<ObjectName object>"; });
}
#+end_src

** Function arguments
- First one must be ~py::arg()~
- Subsequent arguments may be ~""_a~
- When there is a non-obvious type used in the arguments, document it
  - e.g. ~AtomMatrix~ and ~VectorXd~
  - Use ~_~ for spaces, e.g. ~AtomMatrix_pos~ for arguments ~(AtomMatrix pos)~
- When using overloads, always note the actual arguments as comments
#+begin_src cpp
             py::overload_cast<long /*nAtoms*/,
                               AtomMatrix /*positions*/,
                               VectorXi /*atomicNrs*/,
                               double * /*energy*/,
                               Matrix3d /*box*/,
                               int /*nImages*/
                               >(&Potential::force),
#+end_src
* Adding new bindings
- Add to ~py_wrapper.hpp~
#+begin_src c++
PYBIND11_MODULE(eonclient, m) {
    ...
    py_newthing(m);
}
#+end_src
- Make ~py_newthing.cc~
#+begin_src c++
// clang-format off
#include "py_wrapper.hpp"
// Binding code
#include "../Matter.h"
// Additional
#include <pybind11/eigen.h>
#include <pybind11/operators.h>
#include <pybind11/stl.h>
// clang-format on

void py_newthing(py::module_ &m) {
    /* Wrapping details here */
    }
#+end_src
** Potentials
These need to have a helper class defined. They can be tested with:
#+begin_src bash
python -c 'import bbdir.pyeonclient as ec; p=ec.Parameters(); p.potential="morse_pt"; m1=ec.Matter(p); m1.con2matter("pos.con"); a = ec.Morse(); forces, energy = a.energy_and_forces(m1.numberOfAtoms(), m1.getPositions(), m1.getCell()); print(forces); print(energy)'
#+end_src
Or more interactively:
#+begin_src python
import bbdir.pyeonclient as ec
p=ec.Parameters()
p.potential="morse_pt"
m1=ec.Matter(p)
m1.con2matter("gtests/data/systems/Pt_Heptamer_3LayersMove/pos.con")
a = ec.Morse()
forces, energy = a.energy_and_forces(m1.numberOfAtoms(), m1.getPositions(), m1.getCell())
m1.getForces()
m1.getPotentialEnergy()
print(forces)
print(energy)
#+end_src
The helper class is meant *only* to interface easily with Python.
#+begin_src cpp
std::pair<AtomMatrix, double> Morse::energy_and_forces(long nAtoms, AtomMatrix positions, Matrix3d box){
      AtomMatrix forces = AtomMatrix::Constant(nAtoms, 3, 0);
      VectorXi atomicNrs = VectorXi::Constant(nAtoms, 0);
      int *atnrs = atomicNrs.data();
      double *pos = positions.data();
      double *frcs = forces.data();
      double *bx = box.data();
      double energy{0};
      Morse::force(nAtoms, pos, atnrs, frcs, &energy, bx, 1);
      return std::make_pair(forces, energy);
}
#+end_src
** Jobs
For testing:
#+begin_src bash
python -c 'import bbdir.pyeonclient as ec; job = ec.Job(); print(dir(job)); print(job.BASIN_HOPPING)'
#+end_src
*** Saddle Search Jobs
#+begin_src python
import bbdir.pyeonclient as ec
p = ec.Parameters()
p.potential = "morse_pt"
ssj = ec.SaddleSearchJob(p)
ssj.run() # Breaks due to log
#+end_src
