* Conventions
- Always use ~clang-format~.
- All strings must be explicitly identified ~""s~
  + **not for doc-strings** in ~pybind11~
** General
- Always use ~namespace py = pybind11;~
- For ~Blah.cpp~ the binding will be ~pybinds/py_blah.cc~
- Most header content must be in ~pybinds/py_wrapper.hpp~
  + The exceptions are base classes like ~py_potential.hpp~ since these need to be imported by child files like ~potentials/py_morse.cc~
  + If a header is supplied, then the corresponding ~.cc~ should *only* reference the header, which in turn should declare other dependencies.
    - This only applies to files at the same tree/folder level
- Every method must have:
  + arguments defined
  + documentation string
Example:
#+begin_src c++
.def("setCell", &Matter::setCell, "Sets the cell dimensions"s, py::arg("AtomMatrix newCell"))
#+end_src
*** Naming
Naming is hard. To simplify long filenames and deep hierarchies, the following conventions are established:
- Within ~objectivefunctions~, ~ObjectiveFunction~ can be replaced by ~objfunc~
  + So ~MatterObjectiveFunction~ is bound in ~py_matterobjfunc.cc~
** Class boilerplate

#+begin_src c++
void py_objectName(py::module_ &m) {
    py::class_<ObjectName>(m, "ObjectName", py::dynamic_attr()) // dynamic incurs a penalty
    /*
    ,** Constructors
    ,*/

    /*
    ,** Operators
    ,*/

    /*
    ,** Methods
    ,*/

    /*
    ,** Parameters
    ,*/

    /*
    ,** Python helpers
    ,*/

    .def("__repr__", [](const ObjectName &a) { return "<ObjectName object>"; });
}
#+end_src

** Function arguments
- First one must be ~py::arg()~
- Subsequent arguments may be ~""_a~
- When there is a non-obvious type used in the arguments, document it
  - e.g. ~AtomMatrix~ and ~VectorXd~
  - Use ~_~ for spaces, e.g. ~AtomMatrix_pos~ for arguments ~(AtomMatrix pos)~
- When using overloads, always note the actual arguments as comments
#+begin_src cpp
             py::overload_cast<long /*nAtoms*/,
                               AtomMatrix /*positions*/,
                               VectorXi /*atomicNrs*/,
                               double * /*energy*/,
                               Matrix3d /*box*/,
                               int /*nImages*/
                               >(&Potential::force),
#+end_src
* Adding new bindings
- Add to ~py_wrapper.hpp~
#+begin_src c++
PYBIND11_MODULE(eonclient, m) {
    ...
    py_newthing(m);
}
#+end_src
- Make ~py_newthing.cc~
#+begin_src c++
// clang-format off
#include "py_wrapper.hpp"
// Binding code (unless in py_wrapper)
#include "../Log.h"
// clang-format on

void py_newthing(py::module_ &m) {
    /* Wrapping details here */
    }
#+end_src
** Potentials
These need to have a helper class defined. They can be tested with:
#+begin_src bash
python -c 'import bbdir.pyeonclient as ec; p=ec.Parameters(); p.potential="morse_pt"; m1=ec.Matter(p); m1.con2matter("pos.con"); a = ec.Morse(); forces, energy = a.energy_and_forces(m1.numberOfAtoms(), m1.getPositions(), m1.getCell()); print(forces); print(energy)'
#+end_src
Or more interactively:
#+begin_src python
import bbdir.pyeonclient as ec
p=ec.Parameters()
p.potential="morse_pt"
m1=ec.Matter(p)
m1.con2matter("gtests/data/systems/Pt_Heptamer_3LayersMove/pos.con")
a = ec.Morse()
forces, energy = a.energy_and_forces(m1.numberOfAtoms(), m1.getPositions(), m1.getCell())
m1.getForces()
m1.getPotentialEnergy()
print(forces)
print(energy)
#+end_src
The helper class is meant *only* to interface easily with Python.
#+begin_src cpp
std::pair<AtomMatrix, double> Morse::energy_and_forces(long nAtoms, AtomMatrix positions, Matrix3d box){
      AtomMatrix forces = AtomMatrix::Constant(nAtoms, 3, 0);
      VectorXi atomicNrs = VectorXi::Constant(nAtoms, 0);
      int *atnrs = atomicNrs.data();
      double *pos = positions.data();
      double *frcs = forces.data();
      double *bx = box.data();
      double energy{0};
      Morse::force(nAtoms, pos, atnrs, frcs, &energy, bx, 1);
      return std::make_pair(forces, energy);
}
#+end_src
** Jobs
For testing:
#+begin_src bash
python -c 'import bbdir.pyeonclient as ec; job = ec.Job(); print(dir(job)); print(job.BASIN_HOPPING)'
#+end_src
*** Saddle Search Jobs
At this point a working example can be run in ~python~.
#+begin_src python
import bbdir.pyeonclient as ec
p = ec.Parameters()
p.load("config.ini")
ec.log_init(p, "blah.log")
ssj = ec.SaddleSearchJob(p)
ssj.run() # Breaks due to log
#+end_src
** Objective Functions
To test this, an interactive job is nice.
#+begin_src python
import bbdir.pyeonclient as ec
p = ec.Parameters()
p.load("config.ini") # Platinum heptamer, all moving
ec.log_init(p, "blah.log") # Just in case
m1 = ec.Matter(p)
m1.con2matter("pos.con")
mobjf = ec.MatterObjectiveFunction(m1, p) # Make a new objective function
mobjf.getPositions() # returns a vector
mobjf.getPositions().reshape(-1, 3) # atom matrix
mobjf.setPositions((mobjf.getPositions().reshape(-1, 3) + 3).ravel()) # Odd way, but works
mobjf.getEnergy()
mobjf.getConvergence()
mobjf.isConverged()
mobjf.degreesOfFreedom()
mobjf.getGradient()
mobjf.difference(m1.getPositionsFreeV(), mobjf.getPositions()) # TODO: check results?
m1.setPositions(m1.getPositions()+3)
m1.relax(False, False, False, "nope", "00") # TODO: make the last two optional
m1.relax()
#+end_src

** Optimizers
*** LBFGS
These don't seem to be that useful... ~relax~ does the job better.
#+begin_src python
import bbdir.pyeonclient as ec
p = ec.Parameters()
p.load("config.ini") # Platinum heptamer, all moving
ec.log_init(p, "blah.log") # Just in case
m1 = ec.Matter(p)
m1.con2matter("pos.con")
mobjf = ec.MatterObjectiveFunction(m1, p) # Make a new objective function
lbfgsobj = ec.LBFGS(mobjf, p)
mobjf.setPositions(m1.getPositions().ravel()*3+1.5) # high
mobjf.isConverged() # False, needed for the LBFGS to run
lbfgsobj.step(3) # 0 indicates not converged
for i in range(50):
     print(lbfgsobj.run(100, 5))
# Better visuals with relax
m1.relax()
# again
m1.relax
#+end_src
** Nudged Elastic Band
*** NEB class
First we will consider the object, not the job or the objective function.
#+begin_src python
import bbdir.pyeonclient as ec
p = ec.Parameters()
p.load("../examples/neb-al/config.ini") # NEB-Al
ec.log_init(p, "blah.log") # Just in case
product = ec.Matter(p)
product.con2matter("../examples/neb-al/product.con")
reactant = ec.Matter(p)
reactant.con2matter("../examples/neb-al/reactant.con")
neb = ec.NudgedElasticBand(reactant, product, p)
neb.compute()
neb.extremumCurvature
neb.printImageData(False)
#+end_src
This works extremely well.
#+begin_src bash
python -c 'import bbdir.pyeonclient as ec; p = ec.Parameters(); p.load("../examples/neb-al/config.ini") ; ec.log_init(p, "blah.log"); product = ec.Matter(p); product.con2matter("../examples/neb-al/product.con"); reactant = ec.Matter(p); reactant.con2matter("../examples/neb-al/reactant.con"); neb = ec.NudgedElasticBand(reactant, product, p); neb.compute(); neb.extremumCurvature; neb.printImageData(False)'
#+end_src
* Miscellaneous
The main independent components are:
- Parameters :: These have a ~load~ method and consist of static members for the most part
- Matter :: The main class with molecule / atom level writers and readers
- Jobs :: This is the base class for every calculation
- Optimizer :: A class which provides syntactic sugar for working with Objective Functions
- ObjectiveFunction :: The loss definition
