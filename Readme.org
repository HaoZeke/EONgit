* About
- A modern, elegant approach to working with [[https://theory.cm.utexas.edu/eon/][EON]]
** Build
*** Conda
We provide a ~conda~ environment, which is only partially supported for reproducible usage, since it depends on local compilers.
#+begin_src bash
micromamba create -f environment.yml
micromamba activate eongit
#+end_src
This leads to the most robust installation approach:
#+begin_src bash
meson setup bbdir -Dwith_water=false -Dwith_gprd=false -Dwith_fortran=false -Dwith_cuh2=true --buildtype=debug --default-library=shared --prefix=$CONDA_PREFIX
meson install -C bbdir
#+end_src
*** Nix
This is preferred since it is reproducible. You will need [[https://nixos.org/guides/install-nix.html][nix]].
#+begin_src bash
# Debug errors
nix-build -K .
# Add to path
nix-env -if .
#+end_src
**** Development
To get a new shell to work on the packages, use the following:
#+begin_src bash
# With gcc
nix-shell --pure --run bash --show-trace --verbose
# With clang
nix-shell --argstr clang --pure --run bash --show-trace --verbose
#+end_src
***** Linux
In a new sub-shell:
#+begin_src bash
# On Linux machines:
cd client
mkdir build && cd build
cmake .. -DCMAKE_BUILD_TYPE=Debug -DUNIX=TRUE -DPACKAGE_TESTS=ON -DNO_WARN=TRUE -DFIND_EIGEN=TRUE -DCMAKE_EXPORT_COMPILE_COMMANDS=1 -DWITH_GPRD=TRUE -DWITH_FORTRAN=FALSE -G "Ninja"
VERBOSE=1 ninja
ctest
#+end_src
Currently the ~ctests~ are out of date, and ~meson~ is recommended.
***** MacOS
In the new sub-shell:
#+begin_src bash
cd client
./version.sh > version.h
meson setup builddir -Dwith_ams=true -Dwith_gprd=true --buildtype=release
VERBOSE=1 meson compile -C builddir
#+end_src
All the options are documented in ~meson_options.txt~. Occasionally, when the
installation is not done, there may be some linking errors. These can be fixed
by:
#+begin_src bash
# In a conda environment
cd builddir
export LD_LIBRARY_PATH=$CONDA_PREFIX/lib64:$LD_LIBRARY_PATH
export PATH=$(pwd):$PATH
#+end_src
Dependencies can be obtained via:
#+begin_src bash
micromamba env create -f environment.yml
micromamba activate eongit
#+end_src
** Testing
Once ~eonclient~ has been built following the instructions above, we can run integration tests (AKMC) in the development environment.
#+begin_src bash
nix-shell
# In the root directory
pytest
#+end_src
*** TODO Simplify
- [ ] Make a ~default.nix~
  - [ ] Build ~tsase~
  - [x] Build ~eon~
    + Currently works from ~nix-shell~ invocations
  - [x] Build ~eonclient~
*** Meson
This is the preferred method.
#+begin_src bash
cd client
# in conda, add  --prefix=$CONDA_PREFIX
meson setup bbdir --buildtype=debug -Dbuild_tests=true
meson test -C bbdir
#+end_src
**** Writing and Registering Tests
We find that, rather than build each executable by hand or even register each one by hand, we can leverage the array iteration features of the ~meson~ language.
#+begin_src python
if get_option('build_tests')
  _args += ['-DEONTEST'] # Unused
  _deps += [ gtest_dep ]
test_array = [#
  ['Improved Dimer', 'impldim_run', 'ImpDimerTest.cpp', '/gtests/data/saddle_search'],
             ]
foreach test : test_array
  test(test.get(0),
       executable(test.get(1),
          sources : ['gtests/'+test.get(2)],
          dependencies : [ eon_deps, gtest_dep, gmock_dep ],
          link_with : eclib,
          cpp_args : eon_extra_args
                 ),
        workdir : meson.source_root() + test.get(3)
      )
endforeach
endif
#+end_src
*** Cmake
The following will suffice:
#+begin_src bash
cd client
mkdir build && cd build
cmake .. -DCMAKE_BUILD_TYPE=Debug -DPACKAGE_TESTS=ON -DNO_WARN=TRUE
# cmake --build . -- VERBOSE=1
make -j$(nproc) VERBOSE=1 && make check
export PATH=$(pwd):$PATH
#+end_src
**** Tests
~make check~ is typically all that is needed. However, the manual testing methods of the next section work as well.
*** Make
Old style, ugly.
#+begin_src bash
cd client
make -j$(nproc) # Will break
make # Will not break now
export PATH=$(pwd):$PATH
#+end_src
**** Manual Tests
#+begin_src bash
# From root repo directory
cd client/gtests/data/saddle_search/
eonclient
#+end_src
** Usage
Included is the ~eonc.rb~ helper in ~tools/gprdimer/~, which can be used with any of the ~gtests/data/systems~ and a suitable configuration file.
** GPR Dimer Tests
One of ~make check~ tests will break, and this is the GPR dimer call. The tests run in the appropriate test directory; however, debugging ~make check~ is a bit annoying.
*** Debugging
Not the best method, but still cleaner than keeping a whole temporary run folder; we can copy the data into the ~build/gtests~ folder and then debug the test target:
#+begin_src bash
make -j$(nproc) && make check
cd gtests
cp ../../gtests/data/gpr_dimer/client.log ../../gtests/data/gpr_dimer/config.ini ../../gtests/data/gpr_dimer/direction.dat ../../gtests/data/gpr_dimer/displacement.con ../../gtests/data/gpr_dimer/mode.dat ../../gtests/data/gpr_dimer/pos.con ../../gtests/data/gpr_dimer/results.dat .
gdb gprdimereon # or lldb
#+end_src
* Contributing
*Do* run ~pre-commit~ before actually submitting pull requests!
#+begin_src bash
pipx run pre-commit run --all-files
#+end_src
For best results, consider installing the ~git~ hook as well.
#+begin_src bash
pipx run pre-commit install
#+end_src
* Testing
We have both ~Catch2~ unit tests, and also ~ApprovalTests~. For adding new
approval tests, first build them with ~meson compile~, run them to approve, and
then re-run to make sure things pass with ~meson test~.
* TODO Development Rosetta
** Machine Learning Concepts
** EON Concepts
We will establish some terminology to begin with.
- Free Atoms :: These atoms are moved by the client
- Fixed Atoms :: These are the atoms which are indicated in ~con~ files generated by the ~eon~ server to not be moved by the ~eonclient~ binary
- Frozen Atoms :: These are defined in the GPR to be those atoms which do not move; so they are equivalent to ~eon~'s fixed specification
  - Active Frozen :: A GPR only restriction, due to the poor scaling of the high dimensional observations
* License
[[https://opensource.org/licenses/BSD-3-Clause][BSD-3 clause]].
