##-----------------------------------------------------------------------------------
## eOn is free software: you can redistribute it and/or modify
## it under the terms of the GNU General Public License as published by
## the Free Software Foundation, either version 3 of the License, or
## (at your option) any later version.
##
## A copy of the GNU General Public License is available at
## http://www.gnu.org/licenses/
##
##-----------------------------------------------------------------------------------
'''
Con(figuration) i/o library
'''
import ConfigParser
from cStringIO import StringIO
import logging
logger = logging.getLogger('io')
import numpy
import os

import atoms
import config


def length_angle_to_box(boxlengths, angles):
    box = numpy.zeros( (3,3) )
    angles *= numpy.pi/180.0

    box[0][0] = 1.0
    box[1][0] = numpy.cos(angles[0])
    box[1][1] = numpy.sin(angles[0])
    box[2][0] = numpy.cos(angles[1])
    box[2][1] = (numpy.cos(angles[2])-box[1][0]*box[2][0])/box[1][1]
    box[2][2] = numpy.sqrt(1.0-box[2][0]**2-box[2][1]**2)

    box[0,:]*=boxlengths[0]
    box[1,:]*=boxlengths[1]
    box[2,:]*=boxlengths[2]

    return box

def box_to_length_angle(box):
    lengths = numpy.zeros(3)
    lengths[0] = numpy.linalg.norm(box[0,:])
    lengths[1] = numpy.linalg.norm(box[1,:])
    lengths[2] = numpy.linalg.norm(box[2,:])

    angles = numpy.zeros(3)
    angles[0] = numpy.arccos(numpy.dot(box[0,:]/lengths[0],box[1,:]/lengths[1]))
    angles[1] = numpy.arccos(numpy.dot(box[0,:]/lengths[0],box[2,:]/lengths[2]))
    angles[2] = numpy.arccos(numpy.dot(box[1,:]/lengths[1],box[2,:]/lengths[2]))
    angles *= 180.0/numpy.pi

    return lengths, angles

def loadcon(filein):
    '''
    Load a con file
        filein: may be either a filename or a file-like object
    '''
    if hasattr(filein, 'readline'):
        con = filein
    else:
        con = open(filein, 'r')
    con.readline() #Line 1: comment
    con.readline() #Line 2: comment
    # determine how many dimensions
    tmp = numpy.array(con.readline().split()) #Line 3: Box lengths
    for i in range(len(tmp)):
        dim=i+1
        try: float(tmp[i])
        except:
            dim=i
            break
    #handle the box   
    boxlengths=numpy.zeros(dim)
    for i in range(dim):
        boxlengths[i]=float(tmp[i])
    boxangles=numpy.array([ float(f) for f in con.readline().split()[0:dim] ]) #Line 4: Box angles
    boxtemp=numpy.zeros((dim,dim),'d')
    boxtemp = length_angle_to_box(boxlengths,boxangles)
    con.readline() #Line 5: comment
    con.readline() #Line 6: comment
    num_types = int(con.readline().split()[0]) #Line 7: number of atom types
    num_each_type = con.readline().split() #line 8: number of each type of atom
    mass_of_type = con.readline().split() #line 9: mass of each type of atom
    num_atoms = 0
    for i in range(num_types):
        num_each_type[i] = int(num_each_type[i])
        mass_of_type[i] = float(mass_of_type[i])
        num_atoms += num_each_type[i]
    a = atoms.Atoms(num_atoms)
    a.box = boxtemp
    index = 0
    for i in range(num_types):
        name = con.readline().strip()
        con.readline() #skip meaningless line
        for j in range(num_each_type[i]):
            vals = con.readline().split()
            for k in range(dim):
                a.r[index][k] = float(vals[k])
            a.mass[index] = mass_of_type[i]
            a.names[index] = name
            if not int(vals[dim])==0:
                a.free[index]=0       
            index += 1
    return a

def savecon(fileout, p, w = 'w'):
    '''
    Save a con file
        fileout: can be either a file name or a file-like object
        p:       information (in the form of an atoms object) to save
        w:       write/append flag
    '''
    if hasattr(fileout, 'write'):
        con = fileout
    else:
        con = open(fileout, w)
    print >> con, "Generated by eOn"
    print >> con
    dim = len(p.r[0])
    lengths, angles = box_to_length_angle(p.box)
    print >> con, " ".join(['%.4f' % s for s in lengths])
    print >> con, " ".join(['%.4f' % s for s in angles])
    print >> con
    print >> con
    atom_count = {}
    name_order = []
    for i in range(len(p)):
        name = p.names[i]
        if name not in name_order:
            name_order.append(name)
        if name in atom_count:
            atom_count[name] += 1
        else:
            atom_count[name] = 1
    print >> con, len(name_order)
    print >> con, " ".join([str(atom_count[i]) for i in name_order])
    print >> con, " ".join(["%.4f"%p.mass[i] for i in range(len(p.mass)) if i==0 or p.mass[i]!=p.mass[i-1]])
    index = 0
    for i in range(len(name_order)):
        print >> con, name_order[i]
        print >> con, "Coordinates of Component", i+1
        for j in range(atom_count[name_order[i]]):
            con.write("%.3f %.3f %.3f %d %d\n" %( p.r[index][0], p.r[index][1], p.r[index][2], int(not p.free[index]), index+1))
            index += 1


def load_mode(modefilein):
    ''' 
    Reads a mode.dat file into an N by 3 numpy array
        modefilein: may be either a file-like object of a filename
    '''
    if hasattr(modefilein, 'readline'):
        f = modefilein
    else:
        f = open(modefilein, 'r')
    natoms = int(f.readline().split()[0])/3
    ret = numpy.zeros((natoms, 3))
    for i in range(natoms):
        line = f.readline().strip().split()
        for j in range(3):
            ret[i][j] = float(line[j])
    return ret

def save_mode(modefileout, displace_vector, reactant):
    '''
    Saves an Nx3 numpy array into a mode.dat file. 
        modefileout:     may be either a filename or file-like object
        displace_vector: the mode (Nx3 numpy array)
        reactant:        an atoms object that this mode is from. This is used to determine which atoms are free
    '''
    if hasattr(modefileout, 'write'):
        f = modefileout
    else:
        f = open(modefileout, 'w')
    f.write("%d %d\n" % (len(reactant) * 3, 3 * int(reactant.free.sum())))
    for i in range(len(displace_vector)):
        f.write("%.3f %.3f %.3f\n" % (displace_vector[i][0], 
            displace_vector[i][1], displace_vector[i][2]))


def save_results_dat(fileout, results):
    '''
    Saves a results.dat file from a dictionary
    '''
    if hasattr(fileout, 'write'):
        f = fileout
    else:
        f = open(fileout, 'w')
    
    for key in results:
        print >> f, results[key], key

def modify_config(config_path, changes):
    parser = ConfigParser.SafeConfigParser()
    parser.read(config.config_path)
    for change in changes:
        parser.set(*change)
    config_str_io = StringIO()
    parser.write(config_str_io)
    config_str_io.seek(0)
    return config_str_io

def parse_results(filein):
    '''
    Reads a results.dat file and gives a dictionary of the values contained
    therein
    '''
    if hasattr(filein, 'readline'):
        f = filein
    else:
        f = open(filein)
    results = {}
    for line in f:
        line = line.split()
        if len(line) < 2:
            continue
        if '.' in line[0]:
            try:
                results[line[1]] = float(line[0])
            except ValueError:
                logger.warning("couldn't parse float in results.dat: %s", line)
        else:
            try:
                results[line[1]] = int(line[0])
            except ValueError:
                logger.warning("couldn't parse int in results.dat: %s", line)

    return results

def loadposcar(filein):
    '''
    Load the POSCAR file named filename
    Returns an atoms object
    '''
    if hasattr(filein, 'readline'):
        f = filein
    else:
        f = open(filein, 'r')
    # Line 1: Atom types
    AtomTypes = f.readline().split() 
    # Line 2: scaling of coordinates
    scale = float(f.readline()) 
    # Lines 3-5: the box
    box = numpy.zeros((3, 3))
    for i in range(3):
        line = f.readline().split()
        box[i] = numpy.array([float(line[0]), float(line[1]), float(line[2])]) * scale
    # Line 6: number of atoms of each type. 
    line = f.readline().split()
    NumAtomsPerType = []
    for l in line:
        NumAtomsPerType.append(int(l))
    # Now have enough info to make the atoms object.
    num_atoms = sum(NumAtomsPerType)
    p = atoms.Atoms(num_atoms)
    # Fill in the box.
    p.box = box
    # Line 7: selective or cartesian
    sel = f.readline()[0]
    selective_flag = (sel == 's' or sel == 'S')
    if not selective_flag: 
        car = sel
    else: 
        car = f.readline()[0]
    direct_flag = not (car == 'c' or car == 'C' or car == 'k' or car == 'K')
    atom_index = 0
    for i in range(len(NumAtomsPerType)):
        for j in range(NumAtomsPerType[i]):
            p.names[atom_index] = AtomTypes[i]
            line = f.readline().split()
            if(selective_flag): 
                assert len(line) >= 6
            else: 
                assert len(line) >= 3
            pos = line[0:3]
            if selective_flag:
                sel = line[3:7]
                if sel[0] == 'T' or sel[0] == 't': 
                    p.free[atom_index] = 1
                elif sel[0] == 'F' or sel[0] == 'f':
                    p.free[atom_index] = 0
            p.r[atom_index] = numpy.array([float(q) for q in pos])
            if direct_flag:
                p.r[atom_index] = numpy.dot(p.r[atom_index], p.box)
            else: 
                p.r[atom_index] *= scale
            atom_index += 1
    return p    


def saveposcar(fileout, p, w='w', direct = False):
    '''
    Save a POSCAR
        fileout: name to save it under
        point:    atoms object to save
        w:        write/append flag
    ''' 
    if hasattr(fileout, 'write'):
        poscar = fileout
    else:
        poscar = open(fileout, w)
    atom_types = []
    num_each_type = {}
    for name in p.names:
        if not name in atom_types:
            atom_types.append(name)
            num_each_type[name] = 1
        else:
            num_each_type[name] += 1
    print >> poscar, " ".join(atom_types) #Line 1: Atom types
    print >> poscar, 1.0 #Line 2: scaling
    for i in range(3):
        print >> poscar, " ".join(['%20.14f' % s for s in p.box[i]]) #lines 3-5: box
    print >> poscar, " ".join(['%s' % num_each_type[key] for key in atom_types])
    print >> poscar, 'Selective Dynamics' #line 6: selective dynamics
    if direct:
        print >> poscar, 'Direct' #line 7 cartesian coordinates
        ibox = numpy.linalg.inv(numpy.array(p.box))
        p.r = numpy.dot(p.r, ibox)
    else:
        print >> poscar, 'Cartesian' #line 7 cartesian coordinates
    for i in range(len(p)):
            posline = " ".join(['%20.14f' % s for s in p.r[i]]) + " "
            for j in range(3):
                if(p.free[i]): 
                    posline+='   T'
                else: 
                    posline+='   F'
            print >> poscar, posline
            


class Dynamics:
    """ The Dynamics class handles I/O for the dynamics.txt file of an aKMC simulation. """
    
    def __init__(self, filename):
        self.filename = filename
        if not os.path.exists(filename):
            f = open(self.filename, 'w')
            header = "%12s  %12s  %12s  %12s  %12s  %12s  %12s  %12s\n" % ('step-number', 'reactant-id', 'process-id', 'product-id', 'step-time', 'total-time', 'barrier', 'prefactor')
            f.write(header)
            f.write("-" * len(header))
            f.write("\n")
            f.close()      
        f = open(self.filename, 'r')
        self.next_step = len(f.readlines()) - 2
        f.close()
        
    def append(self, reactant_id, process_id, product_id, step_time, total_time, barrier, prefactor):
        f = open(self.filename, 'a')
        f.write("%12d  %12d  %12d  %12d  %12e  %12e  %12e  %12e\n" % (self.next_step, reactant_id, process_id, product_id, step_time, total_time, barrier, prefactor))
        f.close()
        self.next_step += 1

    def get(self):
        f = open(self.filename, 'r')
        lines = f.readlines()[2:]
        f.close()
        data = []
        for line in lines:
            split = line.split()
            data.append({"reactant":    int(split[1]),
                         "process":     int(split[2]),
                         "product":     int(split[3]),
                         "steptime":    float(split[4]),
                         "totaltime":   float(split[5]),
                         "barrier":     float(split[6]),
                         "prefactor":   float(split[7])})
        return data

def load_potfiles(pot_dir):
    ret = {}
    if os.path.isdir(pot_dir):
        for i in os.listdir(pot_dir):
            a = open(os.path.join(pot_dir, i), 'r')
            b = StringIO("".join(a.readlines()))
            ret[i] = b
    return ret
    


if __name__=='__main__':
    import sys
    a=loadcon(sys.argv[1])
    print a.box
    savecon("test.con", a)
